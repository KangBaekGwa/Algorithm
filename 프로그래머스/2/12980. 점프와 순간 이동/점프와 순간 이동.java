// 점프는, 1칸당 1만큼 소비
// 순간이동은, 지금까지 이동한 것 x2 만큼 순간이동
// 뒤로 갈수가 있나? 이게 검증되어야하는데? = 일딴 뒤로 갈 수는 없다고 판단
// 이게 계산으로 할 수 있는 영역인가? 최적화가? => 일딴 나는 불가
// 그럼 현재 위치에서, 할 수 있는 행동은, 점프 or 순간이동 2가지 케이스.
// bfs 는 안됨. 결국 다 검색을 해봐야 하는건가?
// dfs 처럼 탐색을 하되, 중간에 min 값을 항시 저장해두고, 만약 min 보다 현재값이 크다면, 바로 종료하도록 해서 최대한 케이스를 줄여야될 듯.
// 위에꺼 실패. 즉, dfs로는 시간초과
// 도저히 생각이 안남 => 구글링 진행
// 항상 이득인건, 순간이동이 이득.
// 단, 무한정으로 순간이동만 하면, 타겟위치에 도달할 수 없거나 오히려 중간에 점프를 하는게 이득일 경우도 있음.
// 역순으로 생각해서, 현재 위치가 짝수라면 순간이동, 아니라면 -1 이동이 가장 이득?
// 6 -> 3(순간) -> 2(점프) -> 1(순간) -> 0(점프)
// 500 -> 순간이동 -> 250 -> 순간이동 -> 125 -> 점프 -> 124 -> 순간이동 -> 62 -> 순간이동 -> 31 -> 점프 -> 30 -> 순간이동 -> 15 -> 점프 -> 14 -> 순간이동 -> 7 -> 점프 -> 6 -> 순간이동 -> 3 -> 점프 -> 2 -> 순간이동 -> 1 -> 점프 -> 0

//아 5000을 체크해야되네; 에휴
// 5000 -> 순간이동 -> 2500 -> 순간이동 -> 1250 -> 순간이동 -> 625 -> 점프 -> 624 -> 순간이동 -> 312 -> 순간이동 -> 156 -> 순간이동 -> 78 -> 점프 -> 39 -> 점프 -> 38 -> 순간이동 -> 19 -> 점프 -> 18 -> 순간이동 -> 9 -> 순간이동 -> 8 -> 순간이동 -> 4 -> 순간이동 -> 2 -> 순간이동 -> 1 -> 점프 -> 0

import java.util.*;

public class Solution {
    public int solution(int n) {
        int ans = 0;
        
        while(n != 0) {
            //순간이동
            if(n%2 == 0) {
                n /= 2;
                continue;
            }
            
            //점프
            n -= 1;
            ans++;
        }

        return ans;
    }
}